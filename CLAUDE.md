# signalhireagent Development Guidelines

Auto-generated from all feature plans. Last updated: 2025-09-11

## Active Technologies
- Python 3.11 + asyncio (signalhireagent)
- FastAPI (MCP server + autonomous workflows)
- Supabase (PostgreSQL database with real-time features)
- APScheduler (autonomous workflow scheduling)
- Railway (deployment platform with persistent processes)
- httpx (async HTTP client for SignalHire API)
- pandas (CSV data processing and export)
- pydantic (data validation and MCP tool models)
## Project Structure
```
src/
‚îú‚îÄ‚îÄ models/              # Data models (Prospect, SearchCriteria, etc.)
‚îú‚îÄ‚îÄ services/            # Business logic (search, reveal, export services)
‚îú‚îÄ‚îÄ cli/                 # Command-line interface
‚îî‚îÄ‚îÄ lib/                 # Libraries (browser_client, csv_exporter, rate_limiter)
tests/
‚îú‚îÄ‚îÄ contract/            # Browser automation contract tests
‚îú‚îÄ‚îÄ integration/         # End-to-end workflow tests
‚îî‚îÄ‚îÄ unit/               # Unit tests for individual components
```

## CLI Commands for AI Agents

**üìñ Complete Reference**: See `/home/vanman2025/signalhireagent/docs/cli-commands.md`

When the user gives natural language requests, use the CLI command mappings in the reference file:

### Quick Examples:
- **"Find software engineers in California"** ‚Üí `signalhire search --title "Software Engineer" --location "California"`
- **"Merge these contact files"** ‚Üí `signalhire dedupe merge --input "file1.json,file2.json" --output merged.json`
- **"Check my daily limits"** ‚Üí `signalhire status --credits`
- **"Remove operators from contacts"** ‚Üí `signalhire filter job-title --input contacts.json --output filtered.json --exclude-job-titles "operator"`

### Key Features:
- Search with Boolean operators (AND, OR, NOT)
- Contact deduplication and filtering
- Geographic and job title analysis
- Automatic 5000/day limit tracking (search profiles + reveals)
- Progress tracking and resume capability

## Code Style
Python: Follow PEP 8, use async/await patterns, structured logging with JSON
TypeScript: ESLint + Prettier for Stagehand automation scripts

## Testing Commands
- Run tests: `python3 run.py -m pytest`
- Tests with coverage: `python3 run.py -m pytest --cov=src --cov-report=term-missing`
- Test selection: `python3 run.py -m pytest -m unit`, `python3 run.py -m pytest -m "integration and not slow"`
- Check dependencies: `signalhire doctor` (dependency checking only runs for doctor command now for fast startup)

## Task Assignment & Coordination

### My Responsibilities (@claude - Worker Claude)
**Check current spec's tasks.md for @claude assignments:**
- Agent abstraction layer and workflow orchestration
- Supabase database integration and session state management
- Railway deployment configuration and infrastructure
- Cross-service integration and MCP tool coordination
- System architecture and autonomous workflow design

### Task Workflow & Completion Requirements
1. **Check for assignments**: Look for `@claude` in tasks.md
2. **Plan the implementation**: Consider multi-file impacts and integration points
3. **Implement with tests**: Create comprehensive implementation with proper testing
4. **COMMIT YOUR WORK**: All agents MUST commit their code changes when tasks are complete
5. **Mark completion**: Change `[ ]` to `[x]` in tasks.md immediately after finishing - this is your commitment symbol
6. **Document patterns**: Update shared context if new patterns are established

### Critical Completion Protocol
- ‚úÖ **ALWAYS commit code changes** when completing tasks
- ‚úÖ **ALWAYS push commits to remote** immediately after committing (`git push origin main`)
- ‚úÖ **ALWAYS mark tasks as complete** with `[x]` symbol in tasks.md
- ‚úÖ **Use completion symbols** to show you have committed your work
- ‚úÖ **VERIFY 100% FR COMPLIANCE** before merging - all Functional Requirements must be implemented
- ‚úÖ **TEST ALL EDGE CASES** before merging - must handle gracefully, not crash
- ‚ùå **NEVER forget to push commits** - other developers/directories won't see changes until pushed
- ‚ùå **NEVER delete feature branch** until 100% FR compliance verified
- ‚ùå **NEVER leave uncommitted work** when marking tasks complete

### Commit Message Requirements for ALL AGENTS
**MANDATORY**: Every agent must include their identity and task reference in commits:

```bash
# Template for all agents:
git commit -m "$(cat <<'EOF'
[AGENT_ACTION]: Brief description of changes

- Specific change 1
- Specific change 2
- Reference to task numbers completed (e.g., T025, T030)

[AGENT_NAME] completed: T### Task description
Supports: [Project specification reference]

ü§ñ Generated by [AGENT_NAME] with Claude Code

Co-Authored-By: [AGENT_NAME] <noreply@anthropic.com>
EOF
)"
```

**Examples by Agent:**
```bash
# @claude commits:
ü§ñ Generated by Claude with Claude Code
Co-Authored-By: Claude <noreply@anthropic.com>
Claude completed: T025 Add configuration management for API vs browser preferences

# @copilot commits:
ü§ñ Generated by Copilot with Claude Code
Co-Authored-By: Copilot <noreply@anthropic.com>
Copilot completed: T010 CLI improvements for user experience

# @gemini commits:
ü§ñ Generated by Gemini with Claude Code
Co-Authored-By: Gemini <noreply@anthropic.com>
Gemini completed: T029 Update CLI command documentation

# @codex commits:
ü§ñ Generated by Codex with Claude Code
Co-Authored-By: Codex <noreply@anthropic.com>
Codex completed: T004 Enhanced API client contract test
```

### Current @claude Tasks
```bash
# Check my current assignments:
grep "@claude" [current-spec]/tasks.md
```


### Key Focus Areas
- **Supabase Integration**: Database models, session state, real-time features
- **Agent Orchestration**: Multi-agent workflow coordination and tool calling
- **Deployment**: Railway configuration, environment management, production setup
- **Architecture**: MCP server design, autonomous workflow patterns

### Example Task Pattern
```
- [ ] T031 @claude FastAPI callback server for Person API in src/lib/callback_server.py
```
**After completion:**
```
- [x] T031 @claude FastAPI callback server for Person API in src/lib/callback_server.py
```

## Recent Changes
- 004-enterprise-contact-deduplication: Complete contact deduplication and filtering system for enterprise workflows
- Production build system with automated GitHub Actions workflow for clean deployments  
- Robust environment management with virtual environment support and auto-configuration
- Enhanced AI agent integration with comprehensive CLI command references for natural language assistance
- Complete dependency specification and automated release packaging

## Prerequisites
- SignalHire API key (for MCP tool integration)
- Supabase account and project (for database and session state)
- Railway account (for deployment with persistent processes)
- Environment variables: SIGNALHIRE_API_KEY, SUPABASE_URL, SUPABASE_KEY, ANTHROPIC_API_KEY

<!-- MANUAL ADDITIONS START -->

## WSL Environment Notes
- When reading screenshots or working with Windows paths, always use WSL-compatible paths (e.g., `/mnt/c/` instead of `C:\`)
- Screenshots saved by Windows applications should be accessed via WSL path format

## Documentation Guidelines
- ALWAYS check if documentation files already exist before creating new ones
- Use Read tool to verify file existence and content before creating documentation
- NEVER proactively create documentation files (*.md) or README files unless explicitly requested

- Always use absolute paths when reading files

## Production Build System

### Creating Production Deployments
Use the production build script for clean, deployment-ready packages:

```bash
# Create production build in target directory
./scripts/build/build-production.sh ~/target/directory --latest --force

# What it does:
# - Copies only essential application files (src/, docs/, agent instructions)
# - Auto-creates .env with your development credentials
# - Removes development files (tests/, specs/, version.py)
# - Creates install.sh with virtual environment support
# - Includes complete dependency specification
# - Generates CLI wrapper for easy execution
```

### GitHub Actions Integration
Automated releases via `.github/workflows/release.yml`:
- **Triggers**: Version tags (`git tag v0.2.1 && git push origin v0.2.1`) or manual dispatch
- **Builds**: Production packages with clean dependencies
- **Tests**: Validates build integrity and required files
- **Releases**: Creates GitHub releases with downloadable packages

### Testing Production Builds
```bash
# Test locally before releasing
./scripts/build/build-production.sh test-build --latest --force
cd test-build
./install.sh  # Sets up virtual environment and dependencies
./signalhire-agent --help  # Test CLI works
```

## Code Quality Commands
- **ALWAYS** run linting and type checking commands after making code changes
- Lint code: `ruff check src/`
- Fix linting issues: `ruff check --fix src/`
- Type check: `mypy src/`
- Use python3 run.py instead of direct pytest commands for consistent environment setup
- Test message for consistent behavior
- Always validate input parameters in all functions
- Never commit secrets or API keys - always use environment variables and .env files
- You're absolutely right - the environment variable issue is frustrating! The problem is that we're running Python from Windows but the .env file is in the WSL filesystem, so the environment variables aren't being loaded properly. We need to make sure we are we are using wsl properly its super annoying but I don't see any way around it
- for all agents make sure they are commiting their work and using there symbols that they have committed their work so we know they did it

## üö® CRITICAL: Script Documentation Standards
**MANDATORY for ALL AGENTS**: Every script file must include a standardized header.

### Required Header Format:
```bash
#!/bin/bash  # or #!/usr/bin/env python3 for Python
# Script Name
#
# PURPOSE: One-line description of what this script does
# USAGE: ./script-name.sh [arguments] [flags]
# PART OF: Which system/workflow this script belongs to
# CONNECTS TO: What other scripts, workflows, or systems this interacts with
#
# Detailed description explaining key operations and usage notes
```

### Mandatory Fields:
- **PURPOSE**: One-line explanation of what the script does
- **USAGE**: How to run the script with arguments and flags
- **PART OF**: Which larger system or workflow this belongs to
- **CONNECTS TO**: Dependencies, related scripts, or systems it interacts with

### Standards Enforcement:
- ‚úÖ **ALL new scripts MUST include proper headers**
- ‚úÖ **Existing scripts missing headers should be updated when modified**
- ‚úÖ **Reference**: `docs/developer/SCRIPT_HEADER_STANDARD.md` for complete guidelines

## Agent Work Validation Protocol
When checking any agent's completed work, use this systematic validation approach:

### 1. Automated Testing Validation
```bash
# Run the full test suite to catch any breaking changes
python3 run.py -m pytest

# Check specific test categories
python3 run.py -m pytest -m unit
python3 run.py -m pytest -m integration  
```

### 2. Code Quality Checks
```bash
# Lint all code changes
ruff check src/

# Type checking
mypy src/

# Check for any import/dependency issues
python3 -c "import sys; sys.path.append('src'); import services.deduplication_service"
```

### 3. Git Commit Review
```bash
# Check agent's recent commits
git log --grep="[AgentName]" --oneline -10

# Review specific commits with diffs
git show <commit-hash>

# Check if commits follow the required format
git log --grep="ü§ñ Generated by" --oneline -5
```

### 4. Functional Testing
```bash
# Test CLI commands work
signalhire --help
signalhire [command] --help

# Test with sample data if available
[command] --input sample.csv --output test_output.csv
```

### 5. File Structure Validation
```bash
# Check all required files were created
ls -la src/services/
ls -la tests/integration/
ls -la tests/unit/
ls -la src/lib/
```

### Quick Validation Script
Use `scripts/validate-agent-work.sh [agent-name]` for automated validation of agent work.

<!-- MANUAL ADDITIONS END -->
# important-instruction-reminders
Do what has been asked; nothing more, nothing less.
NEVER create files unless they're absolutely necessary for achieving your goal.
ALWAYS prefer editing an existing file to creating a new one.
NEVER proactively create documentation files (*.md) or README files. Only create documentation files if explicitly requested by the User.
ALWAYS check if documentation files already exist before creating new documentation.
Use Read tool to verify file existence and content before creating documentation.
