#!/bin/bash
# Operations CLI Template
# 
# Replaces complex automation with simple, explicit commands
# Perfect for solo development with AI CLI agents
# Template: Customize for your project when copying to other repos

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
CONFIG_FILE="$REPO_ROOT/ops/config.yml"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

print_status() { echo -e "${BLUE}[OPS]${NC} $1"; }
print_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
print_warning() { echo -e "${YELLOW}[WARNING]${NC} $1"; }
print_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# Ensure we're in repo root
cd "$REPO_ROOT"

# Load config if exists
load_config() {
    if [[ -f "$CONFIG_FILE" ]]; then
        # Simple YAML parsing for our basic needs
        return 0
    fi
}

# Get targets from config or default
get_targets() {
    if [[ -f "$CONFIG_FILE" ]] && command -v yq >/dev/null 2>&1; then
        yq e '.targets[]' "$CONFIG_FILE" 2>/dev/null || echo "$HOME/deploy/signalhire"
    else
        echo "$HOME/deploy/signalhire"
    fi
}

# Activate virtual environment
activate_venv() {
    if [[ -f ".venv/bin/activate" ]]; then
        source .venv/bin/activate
    elif [[ -f "venv/bin/activate" ]]; then
        source venv/bin/activate
    else
        print_warning "No virtual environment found - creating .venv..."
        python3 -m venv .venv
        source .venv/bin/activate
        pip install -e .[dev] >/dev/null 2>&1
    fi
}

# Commands
cmd_setup() {
    local target="${1:-$HOME/deploy/project}"
    local auto_release="${2:-false}"
    
    print_status "Setting up project operations"
    print_status "Target: $target"
    
    # Create config
    mkdir -p ops
    cat > "$CONFIG_FILE" << EOF
# Project Operations Config
# Template: Customize for your project
versioning:
  strategy: conventional_commits
  source: pyproject.toml

targets:
  - $target

release:
  changelog: true
  tag_prefix: v
  
qa:
  lint: true
  typecheck: true
  tests: "not slow"
  
env:
  wsl_check: true
  
hooks:
  auto_sync: $auto_release
EOF
    
    print_success "Config created: $CONFIG_FILE"
    print_status "Run: ops qa ‚Üí ops build ‚Üí ops verify-prod ‚Üí ops release"
}

cmd_qa() {
    local test_type="all"
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --backend) test_type="backend"; shift ;;
            --frontend) test_type="frontend"; shift ;;
            --all) test_type="all"; shift ;;
            *) break ;;
        esac
    done
    
    print_status "Running quality assurance checks ($test_type)"
    
    # Backend QA
    if [[ "$test_type" == "backend" ]] || [[ "$test_type" == "all" ]]; then
        activate_venv
        
        echo "üßπ Linting and fixing backend..."
        ruff check src/ --fix || true
        
        echo "üé® Formatting backend..."
        black src/ || true
        
        echo "üîç Type checking backend..."
        mypy src/ || true
        
        echo "üß™ Running backend tests..."
        # Standardized test structure for template consistency
        if [[ -d "tests/backend" ]]; then
            echo "   Using standardized tests/backend/ structure..."
            python3 run.py -m pytest tests/backend/ -m "not slow" || true
        elif [[ -d "tests/unit" ]] && [[ -d "tests/integration" ]]; then
            echo "   Using legacy tests/unit + tests/integration structure..."
            echo "   Running unit tests..."
            python3 run.py -m pytest tests/unit/ -v || true
            echo "   Running integration tests..."
            python3 run.py -m pytest tests/integration/ -m "not slow" -v || true
        else
            echo "   Running all tests (fallback)..."
            python3 run.py -m pytest -m "not slow" || true
        fi
    fi
    
    # Frontend QA
    if [[ "$test_type" == "frontend" ]] || [[ "$test_type" == "all" ]]; then
        if [[ -d "tests/frontend" ]] && [[ -f "package.json" ]]; then
            echo "üßπ Linting frontend..."
            npm run lint:frontend 2>/dev/null || echo "‚ö†Ô∏è Frontend linting not configured"
            
            echo "üîç Type checking frontend..."
            npm run typecheck:frontend 2>/dev/null || echo "‚ö†Ô∏è Frontend type checking not configured"
            
            echo "üé≠ Running frontend tests..."
            npm run test:frontend:smoke 2>/dev/null || npm run test:frontend 2>/dev/null || echo "‚ö†Ô∏è Frontend tests not configured"
        else
            echo "üìù Frontend tests directory not found - skipping frontend QA"
        fi
    fi
    
    print_success "QA complete ($test_type)"
}

cmd_build() {
    local target=""
    local force=false
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --target)
                target="$2"
                shift 2
                ;;
            --force)
                force=true
                shift
                ;;
            *)
                print_error "Unknown option: $1"
                return 1
                ;;
        esac
    done
    
    if [[ -z "$target" ]]; then
        target=$(get_targets | head -1)
    fi
    
    print_status "Building production version to: $target"
    
    # Use existing build script
    if [[ -f "deploy/commands/build-production.sh" ]]; then
        local args=("$target")
        [[ "$force" == true ]] && args+=(--force)
        ./deploy/commands/build-production.sh "${args[@]}"
    else
        # Fallback simple build
        mkdir -p "$target"
        activate_venv
        
        # Copy source
        cp -r src/ "$target/"
        cp pyproject.toml "$target/"
        cp README.md "$target/"
        [[ -f .env ]] && cp .env "$target/"
        
        # Create simple install script
        cat > "$target/install.sh" << 'EOF'
#!/bin/bash
echo "Installing signalhire-agent..."
python3 -m venv .venv
source .venv/bin/activate
pip install -e .
echo "‚úÖ Installation complete!"
echo "Run: ./signalhire-agent --help"
EOF
        chmod +x "$target/install.sh"
        
        # Create CLI wrapper
        cat > "$target/signalhire-agent" << 'EOF'
#!/bin/bash
cd "$(dirname "$0")"
[[ -f .venv/bin/activate ]] && source .venv/bin/activate
python3 run.py "$@"
EOF
        chmod +x "$target/signalhire-agent"
    fi
    
    print_success "Build complete: $target"
}

cmd_verify_prod() {
    local target="${1:-$(get_targets | head -1)}"
    
    print_status "Verifying production build: $target"
    
    if [[ ! -d "$target" ]]; then
        print_error "Target directory not found: $target"
        return 1
    fi
    
    cd "$target"
    
    echo "1Ô∏è‚É£ Testing install script..."
    test -x install.sh || { print_error "install.sh not executable"; return 1; }
    
    echo "2Ô∏è‚É£ Testing CLI wrapper..."
    test -x signalhire-agent || { print_error "signalhire-agent not executable"; return 1; }
    
    echo "3Ô∏è‚É£ Testing help command..."
    ./signalhire-agent --help >/dev/null || { print_error "CLI help failed"; return 1; }
    
    echo "4Ô∏è‚É£ Testing source structure..."
    test -d src/ || { print_error "src/ directory missing"; return 1; }
    
    echo "5Ô∏è‚É£ Running basic tests..."
    if [[ -f ".venv/bin/activate" ]]; then
        source .venv/bin/activate
        python3 -c "import sys; sys.path.append('src'); import cli.main" || { print_error "Import test failed"; return 1; }
    fi
    
    cd "$REPO_ROOT"
    print_success "Production verification passed"
}

cmd_sync() {
    print_status "Syncing to all configured targets"
    
    while IFS= read -r target; do
        if [[ -n "$target" ]]; then
            print_status "Syncing to: $target"
            cmd_build --target "$target" --force
        fi
    done <<< "$(get_targets)"
    
    print_success "Sync complete"
}

cmd_release() {
    local bump_type="${1:-patch}"
    
    print_status "Creating $bump_type release"
    activate_venv
    
    # Get current version from pyproject.toml
    local current_version=$(grep '^version = ' pyproject.toml | sed 's/version = "\(.*\)"/\1/')
    print_status "Current version: $current_version"
    
    # Calculate new version
    IFS='.' read -ra VERSION_PARTS <<< "$current_version"
    local major=${VERSION_PARTS[0]:-0}
    local minor=${VERSION_PARTS[1]:-0}
    local patch=${VERSION_PARTS[2]:-0}
    
    case "$bump_type" in
        major)
            major=$((major + 1))
            minor=0
            patch=0
            ;;
        minor)
            minor=$((minor + 1))
            patch=0
            ;;
        patch)
            patch=$((patch + 1))
            ;;
        *)
            print_error "Invalid bump type: $bump_type (use: major, minor, patch)"
            return 1
            ;;
    esac
    
    local new_version="$major.$minor.$patch"
    print_status "New version: $new_version"
    
    # Update pyproject.toml
    sed -i "s/version = \".*\"/version = \"$new_version\"/" pyproject.toml
    
    # Commit version bump
    git add pyproject.toml
    git commit -m "bump: version $new_version"
    
    # Create and push tag
    git tag "v$new_version"
    git push origin main
    git push origin "v$new_version"
    
    print_success "Release v$new_version created and pushed"
    print_status "GitHub Actions will build and publish the release"
}

cmd_status() {
    print_status "SignalHire Agent Operations Status"
    
    echo "üìÅ Repository: $REPO_ROOT"
    echo "‚öôÔ∏è  Config: $([ -f "$CONFIG_FILE" ] && echo "‚úÖ $CONFIG_FILE" || echo "‚ùå Not found")"
    
    if [[ -f "pyproject.toml" ]]; then
        local version=$(python3 -c "import toml; print(toml.load('pyproject.toml')['project']['version'])" 2>/dev/null || echo "unknown")
        echo "üè∑Ô∏è  Version: $version"
    fi
    
    local last_tag=$(git describe --tags --abbrev=0 2>/dev/null || echo "none")
    echo "üè∑Ô∏è  Last tag: $last_tag"
    
    echo "üéØ Targets:"
    while IFS= read -r target; do
        if [[ -n "$target" ]]; then
            local status="‚ùå"
            [[ -d "$target" ]] && status="‚úÖ"
            echo "   $status $target"
        fi
    done <<< "$(get_targets)"
    
    echo "üêç Environment:"
    if [[ -f ".venv/bin/activate" ]]; then
        echo "   ‚úÖ .venv virtual environment"
    elif [[ -f "venv/bin/activate" ]]; then
        echo "   ‚úÖ venv virtual environment"
    else
        echo "   ‚ùå No virtual environment found"
    fi
}

cmd_env_doctor() {
    print_status "Environment diagnostics"
    
    echo "üêç Python environment:"
    echo "   Python path: $(which python3)"
    echo "   Python version: $(python3 --version)"
    
    if grep -q microsoft /proc/version 2>/dev/null; then
        echo "ü™ü WSL detected"
        
        # Check .env file accessibility
        if [[ -f ".env" ]]; then
            echo "   ‚úÖ .env file found"
            if python3 -c "from dotenv import load_dotenv; load_dotenv()" 2>/dev/null; then
                echo "   ‚úÖ .env file loadable"
            else
                print_warning ".env file exists but not loadable - install python-dotenv"
                echo "   Fix: pip install python-dotenv"
            fi
        else
            print_warning "No .env file found"
            echo "   Create: cp .env.example .env"
        fi
        
        # Check for Windows/WSL path issues
        if echo "$PATH" | grep -q "/mnt/c/"; then
            print_warning "Windows paths detected in WSL PATH"
            echo "   This can cause environment issues"
            echo "   Consider using WSL-native Python: sudo apt install python3-venv"
        fi
    fi
    
    echo "üì¶ Dependencies:"
    activate_venv >/dev/null 2>&1
    local deps_ok=true
    
    for dep in ruff mypy black pytest; do
        if command -v "$dep" >/dev/null 2>&1; then
            echo "   ‚úÖ $dep"
        else
            echo "   ‚ùå $dep"
            deps_ok=false
        fi
    done
    
    if [[ "$deps_ok" == false ]]; then
        print_warning "Missing dependencies detected"
        echo "   Fix: pip install -e .[dev]"
    fi
    
    print_success "Environment check complete"
}

cmd_hooks() {
    local action="$1"
    
    case "$action" in
        install)
            print_status "Installing git hooks for auto-sync"
            cat > .git/hooks/post-commit << 'EOF'
#!/bin/bash
# Auto-sync after commits (optional)
REPO_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/../.." && pwd)"
if [[ -x "$REPO_ROOT/scripts/ops" ]]; then
    "$REPO_ROOT/scripts/ops" sync >/dev/null 2>&1 &
fi
EOF
            chmod +x .git/hooks/post-commit
            print_success "Git hooks installed (auto-sync enabled)"
            ;;
        remove)
            print_status "Removing git hooks"
            rm -f .git/hooks/post-commit
            print_success "Git hooks removed (auto-sync disabled)"
            ;;
        *)
            print_error "Usage: ops hooks [install|remove]"
            return 1
            ;;
    esac
}

# Main command dispatch
case "${1:-help}" in
    setup)
        shift
        cmd_setup "$@"
        ;;
    qa)
        cmd_qa
        ;;
    build)
        shift
        cmd_build "$@"
        ;;
    verify-prod)
        cmd_verify_prod "$2"
        ;;
    sync)
        cmd_sync
        ;;
    release)
        cmd_release "$2"
        ;;
    status)
        cmd_status
        ;;
    env)
        case "$2" in
            doctor)
                cmd_env_doctor
                ;;
            *)
                print_error "Usage: ops env doctor"
                exit 1
                ;;
        esac
        ;;
    hooks)
        cmd_hooks "$2"
        ;;
    help|--help|-h)
        cat << EOF
Project Operations CLI (Template)

USAGE:
    ops <command> [options]

COMMANDS:
    setup [target]           Setup operations config and target directory
    qa [--backend|--frontend|--all]  Run quality checks (lint, format, typecheck, tests)
    build --target PATH      Build production version to target
    verify-prod [target]     Verify production build works correctly
    sync                     Sync to all configured targets
    release [patch|minor|major]  Create and push new release
    status                   Show current status and configuration
    env doctor              Check environment and WSL compatibility
    hooks [install|remove]   Manage auto-sync git hooks (optional)

EXAMPLES:
    ops setup ~/deploy/your-project    # Customize path for your project
    ops qa
    ops build --target ~/deploy/your-project --force
    ops verify-prod
    ops release minor
    ops status
    ops env doctor

WORKFLOW:
    Daily: ops qa ‚Üí ops build ‚Üí ops verify-prod
    Release: ops release [patch|minor|major]
    Sync: ops sync (or enable with ops hooks install)
    
TEMPLATE NOTE:
    This ops system is designed as a template. When copying to other projects,
    customize the QA commands, build scripts, and target paths for your specific stack.
EOF
        ;;
    *)
        print_error "Unknown command: $1"
        print_status "Run 'ops help' for usage information"
        exit 1
        ;;
esac